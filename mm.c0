#use <conio>
// Checks the heap invariants
bool check_heap(heap_t* h)
{
    int cur_header_pos = 0;
    int cur_size = get_block_size(h->heap_mem[cur_header_pos]);
    int cur_footer_pos = cur_header_pos + cur_size - 1;

    while (cur_header_pos < h->size)
    {
        // First and last block should both say their respective prev and last block are allocated
        if (cur_header_pos == 0) {
            if (is_prev_alloc(h->heap_mem[cur_header_pos]) == false) {
                printf("The first block should have the prev block allocated\n");
                printf("Failed at header position %d \n", cur_header_pos);
                return false;
            }
        } else {
            int prev_block_footer = cur_header_pos - 1;
            if (is_alloc(h->heap_mem[prev_block_footer]) != is_prev_alloc(h->heap_mem[cur_header_pos])) {
                printf("Previous allocation bit does not match up with actual allocation status\n");
                printf("Failed at header position %d \n", cur_header_pos);
                return false;
            }
        }
        if (cur_footer_pos >= h->size - 1) {
            if (is_next_alloc(h->heap_mem[cur_header_pos]) == false) {
                printf("The last block should have the next block allocated\n");
                printf("Failed at header position %d \n", cur_header_pos);
                return false;
            }
        } else {
            int next_block_header = cur_footer_pos + 1;
            if (is_alloc(h->heap_mem[next_block_header]) != is_next_alloc(h->heap_mem[cur_header_pos])) {
                printf("Next allocation bit does not match up with actual allocation status\n");
                printf("Failed at header position %d \n", cur_header_pos);
                return false;
            }
        }

        if (cur_size != get_block_size(h->heap_mem[cur_footer_pos])){
            printf("Block sizes don't match on header/footer\n");
            printf("Failed at header position %d \n", cur_header_pos);
            return false;
        }

        // Checking that headers and footers are marked correctly
        if (is_header(h->heap_mem[cur_header_pos]) == false){
            printf("Header block incorrectly marked\n");
            printf("Failed at header position %d \n", cur_header_pos);
            return false;
        }
        if (is_header(h->heap_mem[cur_footer_pos]) == true){
            printf("Footer block incorrectly marked\n");
            printf("Failed at footer position %d \n", cur_footer_pos);
            return false;
        }

        // Checking to make sure the headers agree on metadata
        if (is_alloc(h->heap_mem[cur_header_pos]) != is_alloc(h->heap_mem[cur_footer_pos])){
            printf ("Alloc bits don't match on header/footer\n");
            printf("Failed at header position %d \n", cur_header_pos);
            return false;
        }
        if (is_prev_alloc(h->heap_mem[cur_header_pos]) != is_prev_alloc(h->heap_mem[cur_footer_pos])){
            print_heap(h);
            printf ("Prev alloc bits don't match on header/footer\n");
            printf("Failed at header position %d \n", cur_header_pos);
            return false;
        }
        if (is_next_alloc(h->heap_mem[cur_header_pos]) != is_next_alloc(h->heap_mem[cur_footer_pos])){
            printf ("Next alloc bits don't match on header/footer\n");
            printf("Failed at header position %d \n", cur_header_pos);
            return false;
        }

        cur_header_pos = cur_footer_pos + 1;
        if (cur_header_pos < h->size) {
            cur_size = get_block_size(h->heap_mem[cur_header_pos]);
            cur_footer_pos = cur_header_pos + cur_size - 1;
        }
    }
    return true;
}

void coalesce (heap_t* h, int header_pos)
//@ensures check_heap(h);
{
    
    if (!is_prev_alloc(h->heap_mem[header_pos]) && !is_next_alloc(h->heap_mem[header_pos]))
    {
        // Case where both sides get coalesced
        printf("BOTH coalesce\n");
        int new_header_pos = header_pos - get_block_size(h->heap_mem[header_pos - 1]);
        int header_next = header_pos + get_block_size(h->heap_mem[header_pos]);
        bool prev_alloc = is_prev_alloc(h->heap_mem[new_header_pos]);
        bool next_alloc = is_next_alloc(h->heap_mem[header_next]);
        //@assert is_header(h->heap_mem[header_next]);
        int new_size = get_block_size(h->heap_mem[header_pos]) + get_block_size(h->heap_mem[new_header_pos]) + get_block_size(h->heap_mem[header_next]) - 2;
        obj_t o = make_full_block(h, new_header_pos, new_size, false, prev_alloc, next_alloc);
    } else if (!is_prev_alloc(h->heap_mem[header_pos]) && is_next_alloc(h->heap_mem[header_pos])) 
    {
        // Case where only prev is free
        int new_header_pos = header_pos - get_block_size(h->heap_mem[header_pos - 1]);
        bool prev_alloc = is_prev_alloc(h->heap_mem[new_header_pos]);
        bool next_alloc = is_next_alloc(h->heap_mem[header_pos]);
        int new_size = get_block_size(h->heap_mem[header_pos]) + get_block_size(h->heap_mem[new_header_pos]) - 2;
        obj_t o = make_full_block(h, new_header_pos, new_size, false, prev_alloc, next_alloc);
    } else if (is_prev_alloc(h->heap_mem[header_pos]) && !is_next_alloc(h->heap_mem[header_pos]))
    {
        // Case where only next is free
        int header_next = header_pos + get_block_size(h->heap_mem[header_pos]);
        bool prev_alloc = is_prev_alloc(h->heap_mem[header_pos]);
        bool next_alloc = is_next_alloc(h->heap_mem[header_next]);
        //@assert is_header(h->heap_mem[header_next]);
        int new_size = get_block_size(h->heap_mem[header_pos]) + get_block_size(h->heap_mem[header_next]) - 2;
        obj_t o = make_full_block(h, header_pos, new_size, false, prev_alloc, next_alloc);
    } else {
        int footer_pos = get_block_size(h->heap_mem[header_pos]) -1;
        h->heap_mem[header_pos] = set_free(h->heap_mem[header_pos]);
        h->heap_mem[footer_pos] = set_free(h->heap_mem[footer_pos]);
        
        update_surrounding_blocks(h, header_pos, false);
    }
}

// Returns the allocated object
obj_t split_block(heap_t* h, int header_pos, int size)
//@requires check_heap(h);
//@ensures check_heap(h);
{
    obj_t o;
    int cur_block_size = get_block_size(h->heap_mem[header_pos]);
    if (4 + size < cur_block_size) {
        int next_header_pos = header_pos + size + 2;
        // Subtract 2 twice for both blocks meta data
        int new_size = cur_block_size - size - 4;
        bool prev_alloc = is_prev_alloc(h->heap_mem[header_pos]);
        //@assert prev_alloc == true;
        bool next_alloc = is_next_alloc((h->heap_mem[header_pos]));
        //@assert next_alloc == true;
        o = make_full_block(h, header_pos, size, true, prev_alloc, false);
        //@assert get_footer_pos(o) + 1 == next_header_pos;
        obj_t discard = make_full_block(h, next_header_pos, new_size, false, true, next_alloc);
        //@assert get_header_pos(discard) == next_header_pos;
        //@assert get_obj_size(o) + get_obj_size(discard) + 4 == cur_block_size;
    } else {
        //@assert cur_block_size >= size + 2;
        int real_size = cur_block_size - size - 2;
        bool prev_alloc = is_prev_alloc(h->heap_mem[header_pos]);
        bool next_alloc = is_next_alloc((h->heap_mem[header_pos]));
        o = make_full_block(h, header_pos, real_size, true, prev_alloc, next_alloc);
    }

    //@assert header_pos == get_header_pos(o);

    update_surrounding_blocks(h, header_pos, true);

    return o;
}

// Returning 0 is equivalent to returning NULL
obj_t malloc(heap_t* h, int size)
//@requires check_heap(h);
//@ensures check_heap(h);
{
    // O(n) search, this is what real coding looks like
    int cur_header_pos = 0;
    while(cur_header_pos < h->size && (is_alloc(h->heap_mem[cur_header_pos])) || get_block_size(h->heap_mem[cur_header_pos]) - 2 < size){
        cur_header_pos += get_block_size(h->heap_mem[cur_header_pos]);
    }
    if (cur_header_pos >= h->size){
        return 0;
    }
    
    return split_block(h, cur_header_pos, size);
}

void free(heap_t *h, obj_t obj)
//@requires check_heap(h);
//@ensures check_heap(h);
{
    coalesce(h, get_header_pos(obj));
}