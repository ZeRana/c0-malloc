#use <conio>
#use <util>

// C0 does not have unsigned 64 bit ints, so we have less space (sad)
// Because C0 casting is so annoying blocks are really treated as ints the whole time
// Technically block_t is both a header and a footer, but not the actual payload lol
// First 16 bits are the size of the block (not including the header or footer) the next 4 are for metadata 
// The size is also not byte aligned at all unlike the C malloc implementation we do not assume the last 4 bits are 0s (this is because of the constraints of type casting in C1)
// Metadata bit 1 is the free bit 1 == alloc 0 == free
// Metadata bit 2 is the header/footer bit 1 == header 0 == footer
// Metadata bit 3 is if the prev block is allocated 1 == alloc 0 == free
// Metadata bit 4 is if the next block is allocated 1 == alloc 0 == free
typedef int block_t;

struct heap {
    int size;
    int[] heap_mem; // int array for alignment and ease
};

typedef struct heap heap_t;

// Max size for the heap
// Would normally be a global const, but this is a work around
int max_heap_size(){
    return 0xFFFF;
}

// Max size for the actual payload
int max_payload_size()
{
    return max_heap_size() - 2;
}

// Can be equal to max heap size if the block is the whole heap
// Equal get obj size + 2
int get_block_size(block_t b)
//@ensures \result >= 0;
//@ensures \result <= max_heap_size();
{
    // Getting rid of potentially extraneous negative bits
    return b & 0xFFFF;
}

bool is_header(block_t b)
{
    int h = b & 0x20000;
    h = h >> 17;
    // C0 is annoying about type casting this is a workaround
    return h == 1 ? true : false;
}

bool is_alloc(block_t b){
    b = b & 0x10000;
    b = b >> 16;
    // C0 is annoying about type casting this is a workaround
    return b == 1 ? true : false;
}

block_t set_free(block_t b)
//@ensures !is_alloc(\result);
{
    if (is_alloc(b)){
        b = b ^ 0x10000;
    }
    return b;
}

block_t set_alloc(block_t b)
//@ensures is_alloc(\result);
{
    return b | 0x10000;
}

block_t set_alloc_bit(block_t b, bool is_alloced)
//@ensures is_alloc(\result) == is_alloced;
{
    if (is_alloced) {
        return set_alloc(b);
    } else {
        return set_free(b);
    }
}

int get_footer_from_header(heap_t* h, int header_pos)
{
    return header_pos + get_block_size(h->heap_mem[header_pos]) - 1;
}

int get_header_from_footer(heap_t* h, int footer_pos){
    return footer_pos - get_block_size(h->heap_mem[footer_pos]) + 1;
}

// Sets the alloc bit for both the header and the footer of a block
void set_alloc_block(heap_t* h, int header_pos, bool is_alloced)
{
    int footer_pos = get_footer_from_header(h, header_pos);
    h->heap_mem[header_pos] = set_alloc_bit(h->heap_mem[header_pos], is_alloced);
    h->heap_mem[footer_pos] = set_alloc_bit(h->heap_mem[footer_pos], is_alloced);
}

bool is_prev_alloc(block_t b){
    b = b & 0x40000;
    b = b >> 18;
    // C0 is annoying about type casting this is a workaround
    return b == 1 ? true : false;
}

bool is_next_alloc(block_t b)
{
    b = b & 0x80000;
    b = b >> 19;
    // C0 is annoying about type casting this is a workaround
    return b == 1 ? true : false;
}

block_t set_prev_alloc(block_t b)
//@ensures is_prev_alloc(\result);
{
    return b | 0x40000;
}

block_t set_prev_free(block_t b)
//@ensures !is_prev_alloc(\result);
{
    if (is_prev_alloc(b)){
        b = b ^ 0x40000;
    }
    return b;
}

block_t set_next_alloc(block_t b)
//@ensures is_next_alloc(\result);
{
    return b | 0x80000;
}

block_t set_next_free(block_t b)
//@ensures !is_next_alloc(\result);
{
    if (is_next_alloc(b)){
        b = b ^ 0x80000;
    }
    return b;
}

block_t set_prev(block_t b, bool is_alloced)
//@ensures is_prev_alloc(\result) == is_alloced;
{
    if (is_alloced) {
        return set_prev_alloc(b);
    } else {
        return set_prev_free(b);
    }
}

// Sets the prev bit for the header and the footer of a block
void set_prev_block(heap_t* h, int header_pos,  bool is_alloced)
{
    int footer_pos = get_footer_from_header(h, header_pos);
    h->heap_mem[header_pos] = set_prev(h->heap_mem[header_pos], is_alloced);
    h->heap_mem[footer_pos] = set_prev(h->heap_mem[footer_pos], is_alloced);
}

block_t set_next(block_t b, bool is_alloced)
//@ensures is_next_alloc(\result) == is_alloced;
{
  if (is_alloced) {
        return set_next_alloc(b);
    } else {
        return set_next_free(b);
    }  
}

// Sets the next bit for the header and the footer of a block
void set_next_block(heap_t* h, int header_pos,  bool is_alloced)
{
    int footer_pos = get_footer_from_header(h, header_pos);
    h->heap_mem[header_pos] = set_next(h->heap_mem[header_pos], is_alloced);
    h->heap_mem[footer_pos] = set_next(h->heap_mem[footer_pos], is_alloced);
}

block_t make_block_header(int size, bool is_alloced, bool prev_alloc, bool next_alloc)
//@requires size <= max_heap_size();
//@ensures get_block_size(\result) == size;
//@ensures is_header(\result);
//@ensures is_alloc(\result) == is_alloced;
//@ensures is_prev_alloc(\result) == prev_alloc;
//@ensures is_next_alloc(\result) == next_alloc;
{
    block_t b = size | 0x20000;
    b = set_alloc_bit(b, is_alloced);
    b = set_prev(b, prev_alloc);
    b = set_next(b, next_alloc);
    return b;
}

block_t make_block_footer(int size, bool is_alloced, bool prev_alloc, bool next_alloc)
//@requires size <= max_heap_size();
//@ensures get_block_size(\result) == size;
//@ensures !is_header(\result);
//@ensures is_alloc(\result) == is_alloced;
//@ensures is_prev_alloc(\result) == prev_alloc;
//@ensures is_next_alloc(\result) == next_alloc;
{
    block_t b = size;
    b = set_alloc_bit(b, is_alloced);
    b = set_prev(b, prev_alloc);
    b = set_next(b, next_alloc);
    return b;
}

// First 16 bits is the index position of the header
// Last 16 bits is the index position of the footer
typedef int obj_t;

int get_header_pos(obj_t o){
    return o & 0xFFFF;
}

int get_footer_pos(obj_t o){
    return (o >> 16) & 0xFFFF;
}

// Equals get block size - 2
int get_obj_size(obj_t o)
//@ensures \result <= max_payload_size();
{
    return get_footer_pos(o) - get_header_pos(o) - 1;
}

obj_t make_obj(int header_pos, int footer_pos)
//@requires header_pos <= max_heap_size() - 2;
//@requires footer_pos <= max_heap_size();
//@requires header_pos < footer_pos + 1;
//@ensures get_header_pos(\result) == header_pos;
//@ensures get_footer_pos(\result) == footer_pos;
{
    return (footer_pos << 16) | header_pos;
}

// Updates the prev_alloc bit of the next block
void update_next_block(heap_t* h, int header_pos, bool is_cur_alloc)
{
    int next_header_pos = header_pos + get_block_size(h->heap_mem[header_pos]);
    
    set_prev_block(h, next_header_pos, is_cur_alloc);
}

// Updates the next_alloc bit of the prev block
void update_prev_block(heap_t* h, int header_pos, bool is_cur_alloc)
{
    int prev_header_pos = header_pos - get_block_size(h->heap_mem[header_pos - 1]) + 1;

    set_next_block(h, prev_header_pos, is_cur_alloc);

}

void update_surrounding_blocks(heap_t* h, int header_pos, bool is_cur_alloc){
    if (header_pos != 0) {
        update_prev_block(h, header_pos, is_cur_alloc);
    }
    if (get_block_size(h->heap_mem[header_pos]) + header_pos != h->size){
        update_next_block(h, header_pos, is_cur_alloc);
    }
}

// Size is only the useable data not the metadata
// Real size used = size + 2
obj_t make_full_block(heap_t* heap, int header_pos, int size, bool is_alloced, bool prev_alloc, bool next_alloc)
//@requires header_pos < heap->size;
//@ensures get_header_pos(\result) == header_pos;
//@ensures get_footer_pos(\result) == header_pos + size + 1;
{
    int footer_pos = header_pos + size + 1;

    heap->heap_mem[header_pos] = make_block_header(size + 2, is_alloced, prev_alloc, next_alloc);
    heap->heap_mem[footer_pos] = make_block_footer(size + 2, is_alloced, prev_alloc, next_alloc);
    
    obj_t o = make_obj(header_pos, footer_pos);
    //@assert get_block_size(heap->heap_mem[header_pos]) == get_obj_size(o) + 2;
    return o;
}

// Size is the number of bytes of memory you want to allocate
heap_t* heap_init(int size) 
//@requires size > 0;
//@requires size <= max_payload_size();
//@ensures \length(\result->heap_mem) == size;
{
    heap_t* heap = alloc(heap_t);
    
    int[] heap_mem = alloc_array(int, size);

    heap->size = size;
    heap->heap_mem = heap_mem;

    // We don't actually need the free block this returns
    obj_t b = make_full_block(heap, 0, size-2, false, true, true);

    return heap;
}

void print_metadata(block_t b){
    printf("Metadata: \n");
    if (is_alloc(b)){
        printf("Is allocted \n");
    }
    if (is_prev_alloc(b)){
        printf("Prev is allocted \n");
    }
    if (is_next_alloc(b)){
        printf("Next is allocted \n");
    }
}

// Pass in block header
void print_block(heap_t* h, int header_pos)
//@requires is_header(h->heap_mem[header_pos]);
{
    int size = get_block_size(h->heap_mem[header_pos]);
    int footer_pos = header_pos - 1 + size;

    printf("\nHeader: \n%d block size \n", size);
    print_metadata(h->heap_mem[header_pos]);

    // Lol no need to print freed memory
        if (is_alloc(h->heap_mem[header_pos])) {
            printf("\nData: \n");
            int data_pos = header_pos + 1;
            int index = 0;
            while (data_pos < footer_pos){
            printf("([%d], %d) ", index, (h->heap_mem[data_pos]));
            index++;
            data_pos++;
        }
    }
    
    size = get_block_size(h->heap_mem[footer_pos]);
    printf("\n\nFooter: \n%d block size \n", size);
    print_metadata(h->heap_mem[footer_pos]);
}

void print_heap(heap_t* h)
{
    printf("\nStart Heap \n");
    int cur_header_pos = 0;
    while(cur_header_pos < h->size)
    {
        print_block(h, cur_header_pos);
        cur_header_pos += get_block_size(h->heap_mem[cur_header_pos]);
    }
    printf("End Heap \n\n");
}
