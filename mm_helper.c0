// C0 does not have unsigned 64 bit ints, so we have less space (sad)
// Because C0 casting is so annoying blocks are really treated as ints the whole time
// Technically block_t is both a header and a footer, but not the actual payload lol
// First 16 bits are the size of the block (not including the header or footer) the next 4 are for metadata 
// The size is also not byte aligned at all unlike the C malloc implementation we do not assume the last 4 bits are 0s (this is because of the constraints of type casting in C1)
// Metadata bit 1 is the free bit 1 == alloc 0 == free
// Metadata bit 2 is the header/footer bit 1 == header 0 == footer
typedef int block_t;

// Max size for the heap
// Would normally be a global const, but this is a work around
int max_heap_size(){
    return 0xFFFF;
}

// Max size for the actual payload
int max_payload_size()
{
    return max_heap_size - 2;
}

// Can be equal to max heap size if the block is the whole heap
int get_block_size(block_t b)
//@ensures \result >= 0;
//@ensures \result <= max_heap_size();
{
    // Getting rid of potentially extraneous negative bits
    return b & 0xFFFF;
}

bool is_header(block_t b)
{
    int h = b & 0x20000;
    h = h >> 17;
    // C0 is annoying about type casting this is a workaround
    return h == 1 ? true : false;
}

bool is_alloc(block_t b){
    b = b & 0x10000;
    b = b >> 16;
    // C0 is annoying about type casting this is a workaround
    return b == 1 ? true : false;
}

block_t set_free(block_t b)
//@ensures !is_alloc(\result);
{
    if (is_alloc(b)){
        b = b ^ 0x10000;
    }
    return b;
}

block_t set_alloc(block_t b)
//@ensures is_alloc(\result);
{
    return b | 0x10000;
}

block_t make_block_header(int size)
//@requires size <= max_heap_size();
//@ensures get_block_size(\result) == size;
//@ensures is_header(\result);
//@ensures !is_alloc(\result);
{
    return size | 0x20000;
}

block_t make_block_footer(int size)
//@requires size <= max_heap_size();
//@ensures get_block_size(\result) == size;
//@ensures !is_header(\result);
//@ensures !is_alloc(\result);
{
    return size;
}

struct heap {
    int size;
    int[] heap_mem; // int array for alignment and ease
};

typedef struct heap heap_t;

// First 16 bits is the index position of the header
// Last 16 bits is the index position of the footer
typedef int obj_t;

int get_header_pos(obj_t o){
    return o & 0xFFFF;
}

int get_footer_pos(obj_t o){
    return (o >> 16) & 0xFFFF;
}

int get_obj_size(obj_t o)
//@ensures \result <= max_payload_size();
{
    return get_footer_pos(o) - get_header_pos(o) - 1;
}

obj_t make_obj(int header_pos, int footer_pos)
//@requires header_pos <= max_heap_size() - 2;
//@requires footer_pos <= max_heap_size();
//@requires header_pos < footer_pos + 1;
//@ensures get_header_pos(\result) == header_pos;
//@ensures get_footer_pos(\result) == footer_pos;
{
    return (footer_pos << 16) | header_pos;
}

// Size is only the useable data not the metadata
// Real size used = size + 2
obj_t make_full_block(heap_t* heap, int header_pos, int size, bool is_alloc)
//@requires header_pos < heap->size;
//@ensures get_header_pos(\result) == header_pos;
//@ensures get_footer_pos(\result) == header_pos + size + 1;
{
    int footer_pos = header_pos + size + 1;
    heap->heap_mem[header_pos] = make_block_header(size);
    heap->heap_mem[footer_pos] = make_block_footer(size);
    


    if (is_alloc){
        set_alloc(heap->heap_mem[header_pos]);
        set_alloc(heap->heap_mem[footer_pos]);
    }

    return make_obj(header_pos, footer_pos);
}

// Size is the number of bytes of memory you want to allocate
heap_t* heap_init(int size) 
//@requires size > 0;
//@requires size <= max_payload_size();
//@ensures \length(\result->heap_mem) == size;
{
    heap_t* heap = alloc(heap_t);
    
    int[] heap_mem = alloc_array(int, size);

    heap->size = size;
    heap->heap_mem = heap_mem;

    // We don't actually need the free block this returns
    obj_t b = make_full_block(heap, 0, size-2, false);

    return heap;
}

// Client functions


// This does not require obj to be allocated, because we love double free errors
void free_obj(heap_t* heap, obj_t obj)
{
    set_free(heap->heap_mem[get_header_pos(obj)]);
    set_free(heap->heap_mem[get_footer_pos(obj)]);
}
