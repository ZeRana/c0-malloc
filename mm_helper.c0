//C0 does not have unsigned 64 bit ints, so we have less space (sad)
// Technically block_t is both a header and a footer, but not the actual payload lol
// First 4 bits are metadata last 28 are the size of the block
// Bit 1 is the free bit 1 == alloc 0 == free
// Bit 2 is the header/footer bit 1 == header 0 == footer
typedef int block_t;

// Max size a block can be
// Would normally be a global const, but this is a work around
int max_blocksize(){
    int m = 1 << 28;
    return m - 1;
}

int get_block_size(block_t b)
//@ensures \result >= 0;
//@ensures \result <= max_blocksize();
{
    b = b >> 4;
    // Getting rid of potentially extranious negative bits
    return b & 0x0FFF;
}

bool is_header(block_t b)
{
    int h = b & 0x0002;
    h = h >> 1;
    return (bool)h;
}

bool is_alloc(block_t b){
    b= b & 0x0001;
    return (bool)b;
}

block_t set_free(block_t b)
//@ensures !is_alloc(\result);
{
    if (is_alloc(b)){
        b = b ^ 0x0001;
    }
    return b;
}

block_t set_alloc(block_t b)
//@ensures is_alloc(\result);
{
    return b | 0x0001;
}

block_t make_block_header(int size)
//@ensures get_block_size(\result) == size;
//@ensures is_header(\result);
//@ensures !is_alloc(\result);
{
    int b = size << 4;
    b = b | 0x0002;
    return (block_t)b;
}

struct heap {
    int size;
    char* heap_end; // Technically redundant but its convient, but it is the memory location of the end of the heap
    char[] heap_mem;
};
typedef struct heap heap_t;

// Size is the number of bytes of memory you want to allocate
// If it is less than a multiple of 8 it will be rounded up
heap_t* heap_init(int size) 
//@requires size > 0;
//@ensures \result->size % 8 == 16;
{
    heap_t* heap = alloc(heap_t);

    size = ((size + 7) / 8) * 8;
    // Makes the heap originally an int array so that it is 8 byte aligned
    char[] heap_mem = alloc_array(int, size);

    heap->size = size;
    heap->heap_mem = heap_mem;
    heap->heap_end = (int)heap_mem + size - 1; // Heap is zero indexed

    return heap;
}